"use strict";
/**
 * Enterprise Vulnerability Scanner Service
 * Automated vulnerability scanning and security reporting
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.vulnerabilityScanner = exports.VulnerabilityScanner = void 0;
const events_1 = require("events");
const structured_logger_1 = require("../monitoring/infrastructure/structured-logger");
const performance_metrics_1 = require("../monitoring/infrastructure/performance-metrics");
class VulnerabilityScanner extends events_1.EventEmitter {
    constructor() {
        super();
        this.vulnerabilities = new Map();
        this.scanConfigurations = new Map();
        this.scanResults = new Map();
        this.reports = new Map();
        this.isInitialized = false;
        this.scanQueue = [];
        this.activeScanners = new Set();
        this.maxConcurrentScans = 3;
        this.scanSchedules = new Map();
        this.setupDefaultConfigurations();
    }
    async initialize() {
        if (this.isInitialized) {
            structured_logger_1.logger.warn('Vulnerability scanner already initialized');
            return;
        }
        structured_logger_1.logger.info('Initializing vulnerability scanner');
        try {
            // Setup scan processing
            this.startScanProcessor();
            // Schedule automatic scans
            this.scheduleScans();
            this.isInitialized = true;
            structured_logger_1.logger.info('Vulnerability scanner initialized successfully');
        }
        catch (error) {
            structured_logger_1.logger.error('Failed to initialize vulnerability scanner', error);
            throw error;
        }
    }
    /**
     * Start vulnerability scan
     */
    async startScan(configurationId, triggeredBy = 'manual') {
        const configuration = this.scanConfigurations.get(configurationId);
        if (!configuration) {
            throw new Error(`Scan configuration not found: ${configurationId}`);
        }
        const scanResult = {
            id: this.generateScanId(),
            configurationId,
            type: configuration.type,
            status: 'queued',
            startedAt: new Date(),
            progress: 0,
            targetsCanned: 0,
            vulnerabilities: [],
            summary: {
                total: 0,
                critical: 0,
                high: 0,
                medium: 0,
                low: 0,
                info: 0,
                fixed: 0,
                falsePositives: 0
            },
            errors: [],
            warnings: [],
            metadata: {
                triggeredBy,
                configuration: configuration.name
            }
        };
        this.scanResults.set(scanResult.id, scanResult);
        this.scanQueue.push(scanResult.id);
        // Track scan start
        performance_metrics_1.performanceMetrics.increment('security.scans.started', 1, {
            configurationId,
            type: configuration.type,
            triggeredBy
        });
        structured_logger_1.logger.info('Vulnerability scan queued', {
            scanId: scanResult.id,
            configurationId,
            type: configuration.type,
            triggeredBy
        });
        this.emit('scanQueued', scanResult);
        return scanResult;
    }
    /**
     * Execute scan
     */
    async executeScan(scanId) {
        const scanResult = this.scanResults.get(scanId);
        if (!scanResult) {
            throw new Error(`Scan result not found: ${scanId}`);
        }
        const configuration = this.scanConfigurations.get(scanResult.configurationId);
        if (!configuration) {
            throw new Error(`Scan configuration not found: ${scanResult.configurationId}`);
        }
        try {
            scanResult.status = 'running';
            scanResult.progress = 0;
            this.updateScanResult(scanResult);
            structured_logger_1.logger.info('Starting vulnerability scan', {
                scanId,
                configuration: configuration.name,
                targetsCount: configuration.targets.length
            });
            const startTime = Date.now();
            const foundVulnerabilities = [];
            // Scan each target
            for (let i = 0; i < configuration.targets.length; i++) {
                const target = configuration.targets[i];
                try {
                    scanResult.progress = Math.round((i / configuration.targets.length) * 100);
                    this.updateScanResult(scanResult);
                    // Execute scanners for this target
                    const targetVulnerabilities = await this.scanTarget(target, configuration.scanners);
                    foundVulnerabilities.push(...targetVulnerabilities);
                    scanResult.targetsCanned++;
                }
                catch (error) {
                    scanResult.errors.push(`Target ${target.name}: ${error.message}`);
                    structured_logger_1.logger.error('Target scan failed', {
                        scanId,
                        target: target.name,
                        error: error.message
                    });
                }
            }
            // Process and deduplicate vulnerabilities
            const processedVulnerabilities = this.processVulnerabilities(foundVulnerabilities);
            // Store vulnerabilities
            processedVulnerabilities.forEach(vuln => {
                this.vulnerabilities.set(vuln.id, vuln);
            });
            // Update scan result
            scanResult.vulnerabilities = processedVulnerabilities;
            scanResult.summary = this.calculateSummary(processedVulnerabilities);
            scanResult.status = 'completed';
            scanResult.completedAt = new Date();
            scanResult.duration = Math.round((Date.now() - startTime) / 1000);
            scanResult.progress = 100;
            this.updateScanResult(scanResult);
            // Send notifications
            await this.sendNotifications(configuration, scanResult);
            // Generate reports
            if (configuration.reportingOptions.generateReport) {
                await this.generateScanReport(scanResult);
            }
            // Track scan completion
            performance_metrics_1.performanceMetrics.histogram('security.scans.duration', scanResult.duration, {
                configurationId: scanResult.configurationId,
                type: scanResult.type
            });
            performance_metrics_1.performanceMetrics.increment('security.scans.completed', 1, {
                configurationId: scanResult.configurationId,
                status: scanResult.status
            });
            structured_logger_1.logger.info('Vulnerability scan completed', {
                scanId,
                duration: scanResult.duration,
                vulnerabilities: scanResult.summary.total,
                critical: scanResult.summary.critical,
                high: scanResult.summary.high
            });
            this.emit('scanCompleted', scanResult);
        }
        catch (error) {
            scanResult.status = 'failed';
            scanResult.errors.push(`Scan failed: ${error.message}`);
            scanResult.completedAt = new Date();
            this.updateScanResult(scanResult);
            // Track scan failure
            performance_metrics_1.performanceMetrics.increment('security.scans.failed', 1, {
                configurationId: scanResult.configurationId,
                error: error.name
            });
            structured_logger_1.logger.error('Vulnerability scan failed', {
                scanId,
                error: error.message
            });
            this.emit('scanFailed', scanResult);
        }
    }
    /**
     * Scan individual target
     */
    async scanTarget(target, scanners) {
        const vulnerabilities = [];
        for (const scanner of scanners) {
            if (!scanner.enabled)
                continue;
            try {
                const scannerVulns = await this.runScanner(scanner, target);
                vulnerabilities.push(...scannerVulns);
            }
            catch (error) {
                structured_logger_1.logger.error('Scanner failed', {
                    scannerType: scanner.type,
                    target: target.name,
                    error: error.message
                });
            }
        }
        return vulnerabilities;
    }
    /**
     * Run individual scanner
     */
    async runScanner(scanner, target) {
        switch (scanner.type) {
            case 'sast':
                return this.runSASTScan(target, scanner.configuration);
            case 'dast':
                return this.runDASTScan(target, scanner.configuration);
            case 'dependency':
                return this.runDependencyScan(target, scanner.configuration);
            case 'infrastructure':
                return this.runInfrastructureScan(target, scanner.configuration);
            case 'secrets':
                return this.runSecretsScan(target, scanner.configuration);
            default:
                throw new Error(`Unknown scanner type: ${scanner.type}`);
        }
    }
    /**
     * Static Application Security Testing (SAST)
     */
    async runSASTScan(target, config) {
        const vulnerabilities = [];
        // Mock SAST findings
        if (target.type === 'code_repository') {
            vulnerabilities.push({
                id: this.generateVulnId(),
                title: 'SQL Injection Vulnerability',
                description: 'Potential SQL injection in user input handling',
                severity: 'high',
                cvss: 7.5,
                cwe: 'CWE-89',
                category: 'injection',
                status: 'open',
                discoveredAt: new Date(),
                lastSeen: new Date(),
                source: 'sast',
                location: {
                    type: 'code',
                    path: '/src/user-service.ts',
                    line: 145,
                    function: 'getUserById'
                },
                impact: {
                    confidentiality: 'high',
                    integrity: 'high',
                    availability: 'none'
                },
                exploitability: {
                    attackVector: 'network',
                    attackComplexity: 'low',
                    privilegesRequired: 'low',
                    userInteraction: 'none'
                },
                remediation: {
                    effort: 'medium',
                    priority: 8,
                    recommendation: 'Use parameterized queries or ORM to prevent SQL injection',
                    references: ['https://owasp.org/www-community/attacks/SQL_Injection']
                },
                evidence: {
                    payload: `SELECT * FROM users WHERE id = '${userId}'`,
                    logs: ['Detected direct string concatenation in SQL query']
                },
                metadata: {
                    scanner: 'sast',
                    ruleId: 'SAST-SQL-001',
                    confidence: 'high'
                }
            });
        }
        return vulnerabilities;
    }
    /**
     * Dynamic Application Security Testing (DAST)
     */
    async runDASTScan(target, config) {
        const vulnerabilities = [];
        // Mock DAST findings
        if (target.type === 'web_application') {
            vulnerabilities.push({
                id: this.generateVulnId(),
                title: 'Cross-Site Scripting (XSS)',
                description: 'Reflected XSS vulnerability in search parameter',
                severity: 'medium',
                cvss: 6.1,
                cwe: 'CWE-79',
                category: 'xss',
                status: 'open',
                discoveredAt: new Date(),
                lastSeen: new Date(),
                source: 'dast',
                location: {
                    type: 'code',
                    path: '/search',
                    component: 'search-results'
                },
                impact: {
                    confidentiality: 'low',
                    integrity: 'low',
                    availability: 'none'
                },
                exploitability: {
                    attackVector: 'network',
                    attackComplexity: 'low',
                    privilegesRequired: 'none',
                    userInteraction: 'required'
                },
                remediation: {
                    effort: 'low',
                    priority: 6,
                    recommendation: 'Implement proper input validation and output encoding',
                    references: ['https://owasp.org/www-community/attacks/xss/']
                },
                evidence: {
                    payload: '<script>alert("XSS")</script>',
                    response: 'HTTP/1.1 200 OK\nContent-Type: text/html\n\n<div>Search results for: <script>alert("XSS")</script></div>'
                },
                metadata: {
                    scanner: 'dast',
                    url: `${target.url}/search?q=<script>alert("XSS")</script>`,
                    method: 'GET'
                }
            });
        }
        return vulnerabilities;
    }
    /**
     * Dependency vulnerability scanning
     */
    async runDependencyScan(target, config) {
        const vulnerabilities = [];
        // Mock dependency findings
        vulnerabilities.push({
            id: this.generateVulnId(),
            title: 'Known Vulnerable Dependency',
            description: 'lodash version 4.17.15 has known security vulnerabilities',
            severity: 'medium',
            cvss: 5.3,
            cve: 'CVE-2020-8203',
            category: 'dependency',
            status: 'open',
            discoveredAt: new Date(),
            lastSeen: new Date(),
            source: 'dependency',
            location: {
                type: 'dependency',
                path: '/package.json',
                component: 'lodash@4.17.15'
            },
            impact: {
                confidentiality: 'none',
                integrity: 'low',
                availability: 'high'
            },
            exploitability: {
                attackVector: 'network',
                attackComplexity: 'low',
                privilegesRequired: 'none',
                userInteraction: 'none'
            },
            remediation: {
                effort: 'low',
                priority: 5,
                recommendation: 'Update lodash to version 4.17.21 or later',
                references: ['https://nvd.nist.gov/vuln/detail/CVE-2020-8203']
            },
            evidence: {
                logs: ['Detected vulnerable lodash version in package.json']
            },
            metadata: {
                scanner: 'dependency',
                currentVersion: '4.17.15',
                fixedVersion: '4.17.21',
                packageManager: 'npm'
            }
        });
        return vulnerabilities;
    }
    /**
     * Infrastructure vulnerability scanning
     */
    async runInfrastructureScan(target, config) {
        const vulnerabilities = [];
        // Mock infrastructure findings
        vulnerabilities.push({
            id: this.generateVulnId(),
            title: 'Weak SSL Configuration',
            description: 'Server accepts weak SSL/TLS ciphers',
            severity: 'low',
            cvss: 3.7,
            category: 'crypto',
            status: 'open',
            discoveredAt: new Date(),
            lastSeen: new Date(),
            source: 'infrastructure',
            location: {
                type: 'infrastructure',
                path: target.url || 'unknown',
                component: 'ssl-configuration'
            },
            impact: {
                confidentiality: 'low',
                integrity: 'low',
                availability: 'none'
            },
            exploitability: {
                attackVector: 'network',
                attackComplexity: 'high',
                privilegesRequired: 'none',
                userInteraction: 'none'
            },
            remediation: {
                effort: 'medium',
                priority: 3,
                recommendation: 'Configure server to use only strong SSL/TLS ciphers',
                references: ['https://owasp.org/www-project-cheat-sheets/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html']
            },
            evidence: {
                logs: ['Detected weak cipher: TLS_RSA_WITH_3DES_EDE_CBC_SHA']
            },
            metadata: {
                scanner: 'infrastructure',
                weakCiphers: ['TLS_RSA_WITH_3DES_EDE_CBC_SHA'],
                port: 443
            }
        });
        return vulnerabilities;
    }
    /**
     * Secrets scanning
     */
    async runSecretsScan(target, config) {
        const vulnerabilities = [];
        // Mock secrets findings
        if (target.type === 'code_repository') {
            vulnerabilities.push({
                id: this.generateVulnId(),
                title: 'Hardcoded API Key',
                description: 'Potential API key found in source code',
                severity: 'high',
                cvss: 7.5,
                category: 'info_disclosure',
                status: 'open',
                discoveredAt: new Date(),
                lastSeen: new Date(),
                source: 'secrets',
                location: {
                    type: 'code',
                    path: '/src/config.ts',
                    line: 23
                },
                impact: {
                    confidentiality: 'high',
                    integrity: 'low',
                    availability: 'none'
                },
                exploitability: {
                    attackVector: 'network',
                    attackComplexity: 'low',
                    privilegesRequired: 'none',
                    userInteraction: 'none'
                },
                remediation: {
                    effort: 'low',
                    priority: 9,
                    recommendation: 'Remove hardcoded secrets and use environment variables or secure key management',
                    references: ['https://owasp.org/www-project-cheat-sheets/cheatsheets/Secrets_Management_Cheat_Sheet.html']
                },
                evidence: {
                    payload: 'const apiKey = "sk-1234567890abcdef";'
                },
                metadata: {
                    scanner: 'secrets',
                    secretType: 'api_key',
                    confidence: 'high'
                }
            });
        }
        return vulnerabilities;
    }
    /**
     * Process and deduplicate vulnerabilities
     */
    processVulnerabilities(vulnerabilities) {
        const processed = [];
        const seen = new Set();
        for (const vuln of vulnerabilities) {
            // Create deduplication key
            const dedupKey = `${vuln.category}-${vuln.location.path}-${vuln.title}`;
            if (!seen.has(dedupKey)) {
                seen.add(dedupKey);
                processed.push(vuln);
            }
        }
        return processed;
    }
    /**
     * Calculate vulnerability summary
     */
    calculateSummary(vulnerabilities) {
        const summary = {
            total: vulnerabilities.length,
            critical: 0,
            high: 0,
            medium: 0,
            low: 0,
            info: 0,
            fixed: 0,
            falsePositives: 0
        };
        vulnerabilities.forEach(vuln => {
            switch (vuln.severity) {
                case 'critical':
                    summary.critical++;
                    break;
                case 'high':
                    summary.high++;
                    break;
                case 'medium':
                    summary.medium++;
                    break;
                case 'low':
                    summary.low++;
                    break;
                case 'info':
                    summary.info++;
                    break;
            }
            if (vuln.status === 'fixed') {
                summary.fixed++;
            }
            if (vuln.status === 'false_positive') {
                summary.falsePositives++;
            }
        });
        return summary;
    }
    /**
     * Get vulnerability by ID
     */
    getVulnerability(vulnId) {
        return this.vulnerabilities.get(vulnId) || null;
    }
    /**
     * List vulnerabilities with filters
     */
    listVulnerabilities(filters) {
        let vulnerabilities = Array.from(this.vulnerabilities.values());
        // Apply filters
        if (filters.severity) {
            vulnerabilities = vulnerabilities.filter(v => v.severity === filters.severity);
        }
        if (filters.status) {
            vulnerabilities = vulnerabilities.filter(v => v.status === filters.status);
        }
        if (filters.category) {
            vulnerabilities = vulnerabilities.filter(v => v.category === filters.category);
        }
        if (filters.source) {
            vulnerabilities = vulnerabilities.filter(v => v.source === filters.source);
        }
        if (filters.startDate) {
            vulnerabilities = vulnerabilities.filter(v => v.discoveredAt >= filters.startDate);
        }
        if (filters.endDate) {
            vulnerabilities = vulnerabilities.filter(v => v.discoveredAt <= filters.endDate);
        }
        // Sort by severity and discovery date
        vulnerabilities.sort((a, b) => {
            const severityOrder = { critical: 5, high: 4, medium: 3, low: 2, info: 1 };
            if (severityOrder[a.severity] !== severityOrder[b.severity]) {
                return severityOrder[b.severity] - severityOrder[a.severity];
            }
            return b.discoveredAt.getTime() - a.discoveredAt.getTime();
        });
        // Apply pagination
        const start = filters.offset || 0;
        const end = filters.limit ? start + filters.limit : vulnerabilities.length;
        return vulnerabilities.slice(start, end);
    }
    /**
     * Update vulnerability status
     */
    async updateVulnerability(vulnId, updates, updatedBy) {
        const vulnerability = this.vulnerabilities.get(vulnId);
        if (!vulnerability) {
            throw new Error(`Vulnerability not found: ${vulnId}`);
        }
        const updatedVuln = {
            ...vulnerability,
            ...updates
        };
        if (updates.status === 'fixed' && vulnerability.status !== 'fixed') {
            updatedVuln.fixedAt = new Date();
        }
        this.vulnerabilities.set(vulnId, updatedVuln);
        structured_logger_1.logger.info('Vulnerability updated', {
            vulnId,
            status: updatedVuln.status,
            updatedBy
        });
        this.emit('vulnerabilityUpdated', updatedVuln);
        return updatedVuln;
    }
    /**
     * Get scan result
     */
    getScanResult(scanId) {
        return this.scanResults.get(scanId) || null;
    }
    /**
     * List scan results
     */
    listScanResults(filters) {
        let results = Array.from(this.scanResults.values());
        // Apply filters
        if (filters.configurationId) {
            results = results.filter(r => r.configurationId === filters.configurationId);
        }
        if (filters.status) {
            results = results.filter(r => r.status === filters.status);
        }
        if (filters.startDate) {
            results = results.filter(r => r.startedAt >= filters.startDate);
        }
        if (filters.endDate) {
            results = results.filter(r => r.startedAt <= filters.endDate);
        }
        // Sort by start date desc
        results.sort((a, b) => b.startedAt.getTime() - a.startedAt.getTime());
        // Apply pagination
        const start = filters.offset || 0;
        const end = filters.limit ? start + filters.limit : results.length;
        return results.slice(start, end);
    }
    /**
     * Generate security report
     */
    async generateSecurityReport(type, period, options = {}) {
        const vulnerabilities = this.listVulnerabilities({
            startDate: period.start,
            endDate: period.end
        });
        const report = {
            id: this.generateReportId(),
            title: `Security Report - ${type}`,
            description: `Security report for period ${period.start.toISOString()} to ${period.end.toISOString()}`,
            type,
            generatedAt: new Date(),
            period,
            summary: {
                totalVulnerabilities: vulnerabilities.length,
                newVulnerabilities: vulnerabilities.filter(v => v.discoveredAt >= period.start).length,
                fixedVulnerabilities: vulnerabilities.filter(v => v.status === 'fixed').length,
                riskScore: this.calculateRiskScore(vulnerabilities),
                complianceScore: 85, // Would integrate with compliance service
                trendDirection: 'improving' // Would calculate from historical data
            },
            findings: vulnerabilities,
            recommendations: this.generateRecommendations(vulnerabilities),
            attachments: [],
            metadata: {
                options,
                generatedBy: 'vulnerability-scanner'
            }
        };
        this.reports.set(report.id, report);
        structured_logger_1.logger.info('Security report generated', {
            reportId: report.id,
            type,
            vulnerabilities: report.summary.totalVulnerabilities,
            riskScore: report.summary.riskScore
        });
        this.emit('reportGenerated', report);
        return report;
    }
    setupDefaultConfigurations() {
        // Default comprehensive scan configuration
        const defaultConfig = {
            id: 'default-comprehensive',
            name: 'Comprehensive Security Scan',
            description: 'Full security scan including SAST, DAST, and dependency checks',
            type: 'full',
            enabled: true,
            schedule: '0 2 * * 0', // Weekly on Sunday at 2 AM
            targets: [],
            scanners: [
                {
                    type: 'sast',
                    enabled: true,
                    configuration: { includeExperimental: false },
                    timeout: 1800, // 30 minutes
                    retryCount: 2
                },
                {
                    type: 'dast',
                    enabled: true,
                    configuration: { maxDepth: 3 },
                    timeout: 3600, // 1 hour
                    retryCount: 1
                },
                {
                    type: 'dependency',
                    enabled: true,
                    configuration: { includeDevDependencies: true },
                    timeout: 300, // 5 minutes
                    retryCount: 2
                },
                {
                    type: 'secrets',
                    enabled: true,
                    configuration: { includeGitHistory: false },
                    timeout: 600, // 10 minutes
                    retryCount: 1
                }
            ],
            notifications: [
                {
                    enabled: true,
                    channels: ['email'],
                    severity: ['critical', 'high'],
                    recipients: ['security@company.com']
                }
            ],
            reportingOptions: {
                generateReport: true,
                formats: ['json', 'pdf'],
                includeDetails: true,
                includeFalsePositives: false
            },
            createdAt: new Date(),
            updatedAt: new Date()
        };
        this.scanConfigurations.set(defaultConfig.id, defaultConfig);
        structured_logger_1.logger.info('Default scan configurations loaded', {
            configurationCount: this.scanConfigurations.size
        });
    }
    startScanProcessor() {
        // Process scan queue every 10 seconds
        setInterval(() => {
            this.processScanQueue();
        }, 10000);
    }
    async processScanQueue() {
        if (this.activeScanners.size >= this.maxConcurrentScans) {
            return;
        }
        const scanId = this.scanQueue.shift();
        if (!scanId) {
            return;
        }
        this.activeScanners.add(scanId);
        try {
            await this.executeScan(scanId);
        }
        catch (error) {
            structured_logger_1.logger.error('Scan execution failed', {
                scanId,
                error: error.message
            });
        }
        finally {
            this.activeScanners.delete(scanId);
        }
    }
    scheduleScans() {
        // Schedule scans based on configuration
        for (const config of this.scanConfigurations.values()) {
            if (config.enabled && config.schedule) {
                // Simplified scheduling - would use proper cron in production
                const interval = setInterval(async () => {
                    try {
                        await this.startScan(config.id, 'scheduled');
                    }
                    catch (error) {
                        structured_logger_1.logger.error('Scheduled scan failed', {
                            configurationId: config.id,
                            error: error.message
                        });
                    }
                }, 24 * 60 * 60 * 1000); // Daily
                this.scanSchedules.set(config.id, interval);
            }
        }
    }
    async sendNotifications(config, result) {
        for (const notification of config.notifications) {
            if (!notification.enabled)
                continue;
            const relevantVulns = result.vulnerabilities.filter(v => notification.severity.includes(v.severity));
            if (relevantVulns.length === 0)
                continue;
            structured_logger_1.logger.info('Sending scan notification', {
                scanId: result.id,
                channels: notification.channels,
                vulnerabilities: relevantVulns.length
            });
            // Mock notification sending
            for (const channel of notification.channels) {
                await this.sendNotificationToChannel(channel, notification, result, relevantVulns);
            }
        }
    }
    async sendNotificationToChannel(channel, notification, result, vulnerabilities) {
        switch (channel) {
            case 'email':
                structured_logger_1.logger.info('Sending email notification', {
                    recipients: notification.recipients,
                    vulnerabilities: vulnerabilities.length
                });
                break;
            case 'slack':
                structured_logger_1.logger.info('Sending Slack notification', {
                    vulnerabilities: vulnerabilities.length
                });
                break;
            case 'webhook':
                structured_logger_1.logger.info('Sending webhook notification', {
                    url: notification.webhookUrl,
                    vulnerabilities: vulnerabilities.length
                });
                break;
        }
    }
    async generateScanReport(result) {
        const config = this.scanConfigurations.get(result.configurationId);
        if (!config)
            return;
        structured_logger_1.logger.info('Generating scan report', {
            scanId: result.id,
            formats: config.reportingOptions.formats
        });
        // Mock report generation
        for (const format of config.reportingOptions.formats) {
            await this.generateReportInFormat(result, format);
        }
    }
    async generateReportInFormat(result, format) {
        structured_logger_1.logger.info('Generating report in format', {
            scanId: result.id,
            format
        });
        // Mock report generation
    }
    calculateRiskScore(vulnerabilities) {
        if (vulnerabilities.length === 0)
            return 0;
        const weights = { critical: 10, high: 7, medium: 4, low: 2, info: 1 };
        const totalWeight = vulnerabilities.reduce((sum, v) => sum + weights[v.severity], 0);
        const maxWeight = vulnerabilities.length * 10;
        return Math.round((totalWeight / maxWeight) * 100);
    }
    generateRecommendations(vulnerabilities) {
        const recommendations = [];
        const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
        const high = vulnerabilities.filter(v => v.severity === 'high').length;
        if (critical > 0) {
            recommendations.push(`Address ${critical} critical vulnerabilities immediately`);
        }
        if (high > 0) {
            recommendations.push(`Prioritize ${high} high severity vulnerabilities`);
        }
        const categories = new Set(vulnerabilities.map(v => v.category));
        if (categories.has('injection')) {
            recommendations.push('Implement input validation and parameterized queries');
        }
        if (categories.has('xss')) {
            recommendations.push('Implement proper output encoding and CSP headers');
        }
        if (categories.has('dependency')) {
            recommendations.push('Update dependencies to latest secure versions');
        }
        return recommendations;
    }
    updateScanResult(result) {
        this.scanResults.set(result.id, result);
        this.emit('scanProgress', result);
    }
    generateScanId() {
        return `SCAN-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    generateVulnId() {
        return `VULN-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    generateReportId() {
        return `SRPT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    /**
     * Shutdown service
     */
    async shutdown() {
        // Clear scan schedules
        for (const interval of this.scanSchedules.values()) {
            clearInterval(interval);
        }
        this.scanSchedules.clear();
        // Clear active scanners
        this.activeScanners.clear();
        this.scanQueue.length = 0;
        structured_logger_1.logger.info('Vulnerability scanner shut down');
    }
}
exports.VulnerabilityScanner = VulnerabilityScanner;
exports.vulnerabilityScanner = new VulnerabilityScanner();
//# sourceMappingURL=vulnerability-scanner.service.js.map