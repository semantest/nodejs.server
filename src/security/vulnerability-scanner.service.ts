/**
 * Enterprise Vulnerability Scanner Service
 * Automated vulnerability scanning and security reporting
 */

import { EventEmitter } from 'events';
import { logger } from '../monitoring/infrastructure/structured-logger';
import { performanceMetrics } from '../monitoring/infrastructure/performance-metrics';

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical';
  cvss: number; // Common Vulnerability Scoring System score
  cve?: string; // Common Vulnerabilities and Exposures ID
  cwe?: string; // Common Weakness Enumeration ID
  category: 'authentication' | 'authorization' | 'injection' | 'xss' | 'csrf' | 'crypto' | 'config' | 'dependency' | 'logic' | 'info_disclosure';
  status: 'open' | 'confirmed' | 'false_positive' | 'fixed' | 'accepted_risk';
  discoveredAt: Date;
  lastSeen: Date;
  fixedAt?: Date;
  source: 'sast' | 'dast' | 'iast' | 'dependency' | 'infrastructure' | 'manual';
  location: {
    type: 'code' | 'dependency' | 'infrastructure' | 'configuration';
    path: string;
    line?: number;
    function?: string;
    component?: string;
  };
  impact: {
    confidentiality: 'none' | 'low' | 'high';
    integrity: 'none' | 'low' | 'high';
    availability: 'none' | 'low' | 'high';
  };
  exploitability: {
    attackVector: 'network' | 'adjacent' | 'local' | 'physical';
    attackComplexity: 'low' | 'high';
    privilegesRequired: 'none' | 'low' | 'high';
    userInteraction: 'none' | 'required';
  };
  remediation: {
    effort: 'low' | 'medium' | 'high';
    priority: number; // 1-10 scale
    recommendation: string;
    references: string[];
  };
  evidence: {
    payload?: string;
    response?: string;
    screenshot?: string;
    logs?: string[];
  };
  metadata: Record<string, any>;
}

export interface ScanConfiguration {
  id: string;
  name: string;
  description: string;
  type: 'full' | 'quick' | 'focused';
  enabled: boolean;
  schedule: string; // cron expression
  targets: ScanTarget[];
  scanners: ScannerConfig[];
  notifications: NotificationConfig[];
  reportingOptions: ReportingOptions;
  createdAt: Date;
  updatedAt: Date;
}

export interface ScanTarget {
  id: string;
  type: 'web_application' | 'api' | 'infrastructure' | 'code_repository' | 'dependency';
  name: string;
  url?: string;
  path?: string;
  credentials?: {
    type: 'basic' | 'bearer' | 'api_key' | 'oauth';
    username?: string;
    password?: string;
    token?: string;
  };
  excludePatterns?: string[];
  includePatterns?: string[];
  metadata: Record<string, any>;
}

export interface ScannerConfig {
  type: 'sast' | 'dast' | 'dependency' | 'infrastructure' | 'secrets';
  enabled: boolean;
  configuration: Record<string, any>;
  timeout: number; // in seconds
  retryCount: number;
}

export interface NotificationConfig {
  enabled: boolean;
  channels: ('email' | 'slack' | 'webhook')[];
  severity: Vulnerability['severity'][];
  recipients: string[];
  webhookUrl?: string;
}

export interface ReportingOptions {
  generateReport: boolean;
  formats: ('json' | 'xml' | 'pdf' | 'html')[];
  includeDetails: boolean;
  includeFalsePositives: boolean;
  customTemplate?: string;
}

export interface ScanResult {
  id: string;
  configurationId: string;
  type: ScanConfiguration['type'];
  status: 'queued' | 'running' | 'completed' | 'failed' | 'cancelled';
  startedAt: Date;
  completedAt?: Date;
  duration?: number; // in seconds
  progress: number; // 0-100
  targetsCanned: number;
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
    fixed: number;
    falsePositives: number;
  };
  errors: string[];
  warnings: string[];
  metadata: Record<string, any>;
}

export interface SecurityReport {
  id: string;
  title: string;
  description: string;
  type: 'vulnerability' | 'compliance' | 'security_posture' | 'trend_analysis';
  generatedAt: Date;
  period: { start: Date; end: Date };
  summary: {
    totalVulnerabilities: number;
    newVulnerabilities: number;
    fixedVulnerabilities: number;
    riskScore: number;
    complianceScore: number;
    trendDirection: 'improving' | 'stable' | 'deteriorating';
  };
  findings: Vulnerability[];
  recommendations: string[];
  attachments: string[];
  metadata: Record<string, any>;
}

export class VulnerabilityScanner extends EventEmitter {
  private vulnerabilities: Map<string, Vulnerability> = new Map();
  private scanConfigurations: Map<string, ScanConfiguration> = new Map();
  private scanResults: Map<string, ScanResult> = new Map();
  private reports: Map<string, SecurityReport> = new Map();
  private isInitialized = false;
  private scanQueue: string[] = [];
  private activeScanners = new Set<string>();
  private maxConcurrentScans = 3;
  private scanSchedules: Map<string, NodeJS.Timeout> = new Map();

  constructor() {
    super();
    this.setupDefaultConfigurations();
  }

  async initialize(): Promise<void> {
    if (this.isInitialized) {
      logger.warn('Vulnerability scanner already initialized');
      return;
    }

    logger.info('Initializing vulnerability scanner');

    try {
      // Setup scan processing
      this.startScanProcessor();
      
      // Schedule automatic scans
      this.scheduleScans();
      
      this.isInitialized = true;
      logger.info('Vulnerability scanner initialized successfully');
      
    } catch (error) {
      logger.error('Failed to initialize vulnerability scanner', error);
      throw error;
    }
  }

  /**
   * Start vulnerability scan
   */
  async startScan(configurationId: string, triggeredBy: string = 'manual'): Promise<ScanResult> {
    const configuration = this.scanConfigurations.get(configurationId);
    if (!configuration) {
      throw new Error(`Scan configuration not found: ${configurationId}`);
    }

    const scanResult: ScanResult = {
      id: this.generateScanId(),
      configurationId,
      type: configuration.type,
      status: 'queued',
      startedAt: new Date(),
      progress: 0,
      targetsCanned: 0,
      vulnerabilities: [],
      summary: {
        total: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        info: 0,
        fixed: 0,
        falsePositives: 0
      },
      errors: [],
      warnings: [],
      metadata: {
        triggeredBy,
        configuration: configuration.name
      }
    };

    this.scanResults.set(scanResult.id, scanResult);
    this.scanQueue.push(scanResult.id);

    // Track scan start
    performanceMetrics.increment('security.scans.started', 1, {
      configurationId,
      type: configuration.type,
      triggeredBy
    });

    logger.info('Vulnerability scan queued', {
      scanId: scanResult.id,
      configurationId,
      type: configuration.type,
      triggeredBy
    });

    this.emit('scanQueued', scanResult);
    return scanResult;
  }

  /**
   * Execute scan
   */
  private async executeScan(scanId: string): Promise<void> {
    const scanResult = this.scanResults.get(scanId);
    if (!scanResult) {
      throw new Error(`Scan result not found: ${scanId}`);
    }

    const configuration = this.scanConfigurations.get(scanResult.configurationId);
    if (!configuration) {
      throw new Error(`Scan configuration not found: ${scanResult.configurationId}`);
    }

    try {
      scanResult.status = 'running';
      scanResult.progress = 0;
      this.updateScanResult(scanResult);

      logger.info('Starting vulnerability scan', {
        scanId,
        configuration: configuration.name,
        targetsCount: configuration.targets.length
      });

      const startTime = Date.now();
      const foundVulnerabilities: Vulnerability[] = [];

      // Scan each target
      for (let i = 0; i < configuration.targets.length; i++) {
        const target = configuration.targets[i];
        
        try {
          scanResult.progress = Math.round((i / configuration.targets.length) * 100);
          this.updateScanResult(scanResult);

          // Execute scanners for this target
          const targetVulnerabilities = await this.scanTarget(target, configuration.scanners);
          foundVulnerabilities.push(...targetVulnerabilities);
          
          scanResult.targetsCanned++;
          
        } catch (error) {
          scanResult.errors.push(`Target ${target.name}: ${error.message}`);
          logger.error('Target scan failed', {
            scanId,
            target: target.name,
            error: error.message
          });
        }
      }

      // Process and deduplicate vulnerabilities
      const processedVulnerabilities = this.processVulnerabilities(foundVulnerabilities);
      
      // Store vulnerabilities
      processedVulnerabilities.forEach(vuln => {
        this.vulnerabilities.set(vuln.id, vuln);
      });

      // Update scan result
      scanResult.vulnerabilities = processedVulnerabilities;
      scanResult.summary = this.calculateSummary(processedVulnerabilities);
      scanResult.status = 'completed';
      scanResult.completedAt = new Date();
      scanResult.duration = Math.round((Date.now() - startTime) / 1000);
      scanResult.progress = 100;

      this.updateScanResult(scanResult);

      // Send notifications
      await this.sendNotifications(configuration, scanResult);

      // Generate reports
      if (configuration.reportingOptions.generateReport) {
        await this.generateScanReport(scanResult);
      }

      // Track scan completion
      performanceMetrics.histogram('security.scans.duration', scanResult.duration, {
        configurationId: scanResult.configurationId,
        type: scanResult.type
      });

      performanceMetrics.increment('security.scans.completed', 1, {
        configurationId: scanResult.configurationId,
        status: scanResult.status
      });

      logger.info('Vulnerability scan completed', {
        scanId,
        duration: scanResult.duration,
        vulnerabilities: scanResult.summary.total,
        critical: scanResult.summary.critical,
        high: scanResult.summary.high
      });

      this.emit('scanCompleted', scanResult);

    } catch (error) {
      scanResult.status = 'failed';
      scanResult.errors.push(`Scan failed: ${error.message}`);
      scanResult.completedAt = new Date();
      
      this.updateScanResult(scanResult);

      // Track scan failure
      performanceMetrics.increment('security.scans.failed', 1, {
        configurationId: scanResult.configurationId,
        error: error.name
      });

      logger.error('Vulnerability scan failed', {
        scanId,
        error: error.message
      });

      this.emit('scanFailed', scanResult);
    }
  }

  /**
   * Scan individual target
   */
  private async scanTarget(target: ScanTarget, scanners: ScannerConfig[]): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    for (const scanner of scanners) {
      if (!scanner.enabled) continue;

      try {
        const scannerVulns = await this.runScanner(scanner, target);
        vulnerabilities.push(...scannerVulns);
      } catch (error) {
        logger.error('Scanner failed', {
          scannerType: scanner.type,
          target: target.name,
          error: error.message
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Run individual scanner
   */
  private async runScanner(scanner: ScannerConfig, target: ScanTarget): Promise<Vulnerability[]> {
    switch (scanner.type) {
      case 'sast':
        return this.runSASTScan(target, scanner.configuration);
      case 'dast':
        return this.runDASTScan(target, scanner.configuration);
      case 'dependency':
        return this.runDependencyScan(target, scanner.configuration);
      case 'infrastructure':
        return this.runInfrastructureScan(target, scanner.configuration);
      case 'secrets':
        return this.runSecretsScan(target, scanner.configuration);
      default:
        throw new Error(`Unknown scanner type: ${scanner.type}`);
    }
  }

  /**
   * Static Application Security Testing (SAST)
   */
  private async runSASTScan(target: ScanTarget, config: any): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Mock SAST findings
    if (target.type === 'code_repository') {
      vulnerabilities.push({
        id: this.generateVulnId(),
        title: 'SQL Injection Vulnerability',
        description: 'Potential SQL injection in user input handling',
        severity: 'high',
        cvss: 7.5,
        cwe: 'CWE-89',
        category: 'injection',
        status: 'open',
        discoveredAt: new Date(),
        lastSeen: new Date(),
        source: 'sast',
        location: {
          type: 'code',
          path: '/src/user-service.ts',
          line: 145,
          function: 'getUserById'
        },
        impact: {
          confidentiality: 'high',
          integrity: 'high',
          availability: 'none'
        },
        exploitability: {
          attackVector: 'network',
          attackComplexity: 'low',
          privilegesRequired: 'low',
          userInteraction: 'none'
        },
        remediation: {
          effort: 'medium',
          priority: 8,
          recommendation: 'Use parameterized queries or ORM to prevent SQL injection',
          references: ['https://owasp.org/www-community/attacks/SQL_Injection']
        },
        evidence: {
          payload: `SELECT * FROM users WHERE id = '${userId}'`,
          logs: ['Detected direct string concatenation in SQL query']
        },
        metadata: {
          scanner: 'sast',
          ruleId: 'SAST-SQL-001',
          confidence: 'high'
        }
      });
    }

    return vulnerabilities;
  }

  /**
   * Dynamic Application Security Testing (DAST)
   */
  private async runDASTScan(target: ScanTarget, config: any): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Mock DAST findings
    if (target.type === 'web_application') {
      vulnerabilities.push({
        id: this.generateVulnId(),
        title: 'Cross-Site Scripting (XSS)',
        description: 'Reflected XSS vulnerability in search parameter',
        severity: 'medium',
        cvss: 6.1,
        cwe: 'CWE-79',
        category: 'xss',
        status: 'open',
        discoveredAt: new Date(),
        lastSeen: new Date(),
        source: 'dast',
        location: {
          type: 'code',
          path: '/search',
          component: 'search-results'
        },
        impact: {
          confidentiality: 'low',
          integrity: 'low',
          availability: 'none'
        },
        exploitability: {
          attackVector: 'network',
          attackComplexity: 'low',
          privilegesRequired: 'none',
          userInteraction: 'required'
        },
        remediation: {
          effort: 'low',
          priority: 6,
          recommendation: 'Implement proper input validation and output encoding',
          references: ['https://owasp.org/www-community/attacks/xss/']
        },
        evidence: {
          payload: '<script>alert("XSS")</script>',
          response: 'HTTP/1.1 200 OK\nContent-Type: text/html\n\n<div>Search results for: <script>alert("XSS")</script></div>'
        },
        metadata: {
          scanner: 'dast',
          url: `${target.url}/search?q=<script>alert("XSS")</script>`,
          method: 'GET'
        }
      });
    }

    return vulnerabilities;
  }

  /**
   * Dependency vulnerability scanning
   */
  private async runDependencyScan(target: ScanTarget, config: any): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Mock dependency findings
    vulnerabilities.push({
      id: this.generateVulnId(),
      title: 'Known Vulnerable Dependency',
      description: 'lodash version 4.17.15 has known security vulnerabilities',
      severity: 'medium',
      cvss: 5.3,
      cve: 'CVE-2020-8203',
      category: 'dependency',
      status: 'open',
      discoveredAt: new Date(),
      lastSeen: new Date(),
      source: 'dependency',
      location: {
        type: 'dependency',
        path: '/package.json',
        component: 'lodash@4.17.15'
      },
      impact: {
        confidentiality: 'none',
        integrity: 'low',
        availability: 'high'
      },
      exploitability: {
        attackVector: 'network',
        attackComplexity: 'low',
        privilegesRequired: 'none',
        userInteraction: 'none'
      },
      remediation: {
        effort: 'low',
        priority: 5,
        recommendation: 'Update lodash to version 4.17.21 or later',
        references: ['https://nvd.nist.gov/vuln/detail/CVE-2020-8203']
      },
      evidence: {
        logs: ['Detected vulnerable lodash version in package.json']
      },
      metadata: {
        scanner: 'dependency',
        currentVersion: '4.17.15',
        fixedVersion: '4.17.21',
        packageManager: 'npm'
      }
    });

    return vulnerabilities;
  }

  /**
   * Infrastructure vulnerability scanning
   */
  private async runInfrastructureScan(target: ScanTarget, config: any): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Mock infrastructure findings
    vulnerabilities.push({
      id: this.generateVulnId(),
      title: 'Weak SSL Configuration',
      description: 'Server accepts weak SSL/TLS ciphers',
      severity: 'low',
      cvss: 3.7,
      category: 'crypto',
      status: 'open',
      discoveredAt: new Date(),
      lastSeen: new Date(),
      source: 'infrastructure',
      location: {
        type: 'infrastructure',
        path: target.url || 'unknown',
        component: 'ssl-configuration'
      },
      impact: {
        confidentiality: 'low',
        integrity: 'low',
        availability: 'none'
      },
      exploitability: {
        attackVector: 'network',
        attackComplexity: 'high',
        privilegesRequired: 'none',
        userInteraction: 'none'
      },
      remediation: {
        effort: 'medium',
        priority: 3,
        recommendation: 'Configure server to use only strong SSL/TLS ciphers',
        references: ['https://owasp.org/www-project-cheat-sheets/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html']
      },
      evidence: {
        logs: ['Detected weak cipher: TLS_RSA_WITH_3DES_EDE_CBC_SHA']
      },
      metadata: {
        scanner: 'infrastructure',
        weakCiphers: ['TLS_RSA_WITH_3DES_EDE_CBC_SHA'],
        port: 443
      }
    });

    return vulnerabilities;
  }

  /**
   * Secrets scanning
   */
  private async runSecretsScan(target: ScanTarget, config: any): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Mock secrets findings
    if (target.type === 'code_repository') {
      vulnerabilities.push({
        id: this.generateVulnId(),
        title: 'Hardcoded API Key',
        description: 'Potential API key found in source code',
        severity: 'high',
        cvss: 7.5,
        category: 'info_disclosure',
        status: 'open',
        discoveredAt: new Date(),
        lastSeen: new Date(),
        source: 'secrets',
        location: {
          type: 'code',
          path: '/src/config.ts',
          line: 23
        },
        impact: {
          confidentiality: 'high',
          integrity: 'low',
          availability: 'none'
        },
        exploitability: {
          attackVector: 'network',
          attackComplexity: 'low',
          privilegesRequired: 'none',
          userInteraction: 'none'
        },
        remediation: {
          effort: 'low',
          priority: 9,
          recommendation: 'Remove hardcoded secrets and use environment variables or secure key management',
          references: ['https://owasp.org/www-project-cheat-sheets/cheatsheets/Secrets_Management_Cheat_Sheet.html']
        },
        evidence: {
          payload: 'const apiKey = "sk-1234567890abcdef";'
        },
        metadata: {
          scanner: 'secrets',
          secretType: 'api_key',
          confidence: 'high'
        }
      });
    }

    return vulnerabilities;
  }

  /**
   * Process and deduplicate vulnerabilities
   */
  private processVulnerabilities(vulnerabilities: Vulnerability[]): Vulnerability[] {
    const processed: Vulnerability[] = [];
    const seen = new Set<string>();

    for (const vuln of vulnerabilities) {
      // Create deduplication key
      const dedupKey = `${vuln.category}-${vuln.location.path}-${vuln.title}`;
      
      if (!seen.has(dedupKey)) {
        seen.add(dedupKey);
        processed.push(vuln);
      }
    }

    return processed;
  }

  /**
   * Calculate vulnerability summary
   */
  private calculateSummary(vulnerabilities: Vulnerability[]): ScanResult['summary'] {
    const summary = {
      total: vulnerabilities.length,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0,
      fixed: 0,
      falsePositives: 0
    };

    vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case 'critical':
          summary.critical++;
          break;
        case 'high':
          summary.high++;
          break;
        case 'medium':
          summary.medium++;
          break;
        case 'low':
          summary.low++;
          break;
        case 'info':
          summary.info++;
          break;
      }

      if (vuln.status === 'fixed') {
        summary.fixed++;
      }
      if (vuln.status === 'false_positive') {
        summary.falsePositives++;
      }
    });

    return summary;
  }

  /**
   * Get vulnerability by ID
   */
  getVulnerability(vulnId: string): Vulnerability | null {
    return this.vulnerabilities.get(vulnId) || null;
  }

  /**
   * List vulnerabilities with filters
   */
  listVulnerabilities(filters: {
    severity?: Vulnerability['severity'];
    status?: Vulnerability['status'];
    category?: Vulnerability['category'];
    source?: Vulnerability['source'];
    startDate?: Date;
    endDate?: Date;
    limit?: number;
    offset?: number;
  }): Vulnerability[] {
    let vulnerabilities = Array.from(this.vulnerabilities.values());

    // Apply filters
    if (filters.severity) {
      vulnerabilities = vulnerabilities.filter(v => v.severity === filters.severity);
    }
    if (filters.status) {
      vulnerabilities = vulnerabilities.filter(v => v.status === filters.status);
    }
    if (filters.category) {
      vulnerabilities = vulnerabilities.filter(v => v.category === filters.category);
    }
    if (filters.source) {
      vulnerabilities = vulnerabilities.filter(v => v.source === filters.source);
    }
    if (filters.startDate) {
      vulnerabilities = vulnerabilities.filter(v => v.discoveredAt >= filters.startDate!);
    }
    if (filters.endDate) {
      vulnerabilities = vulnerabilities.filter(v => v.discoveredAt <= filters.endDate!);
    }

    // Sort by severity and discovery date
    vulnerabilities.sort((a, b) => {
      const severityOrder = { critical: 5, high: 4, medium: 3, low: 2, info: 1 };
      if (severityOrder[a.severity] !== severityOrder[b.severity]) {
        return severityOrder[b.severity] - severityOrder[a.severity];
      }
      return b.discoveredAt.getTime() - a.discoveredAt.getTime();
    });

    // Apply pagination
    const start = filters.offset || 0;
    const end = filters.limit ? start + filters.limit : vulnerabilities.length;
    
    return vulnerabilities.slice(start, end);
  }

  /**
   * Update vulnerability status
   */
  async updateVulnerability(
    vulnId: string,
    updates: Partial<Vulnerability>,
    updatedBy: string
  ): Promise<Vulnerability> {
    const vulnerability = this.vulnerabilities.get(vulnId);
    if (!vulnerability) {
      throw new Error(`Vulnerability not found: ${vulnId}`);
    }

    const updatedVuln: Vulnerability = {
      ...vulnerability,
      ...updates
    };

    if (updates.status === 'fixed' && vulnerability.status !== 'fixed') {
      updatedVuln.fixedAt = new Date();
    }

    this.vulnerabilities.set(vulnId, updatedVuln);

    logger.info('Vulnerability updated', {
      vulnId,
      status: updatedVuln.status,
      updatedBy
    });

    this.emit('vulnerabilityUpdated', updatedVuln);
    return updatedVuln;
  }

  /**
   * Get scan result
   */
  getScanResult(scanId: string): ScanResult | null {
    return this.scanResults.get(scanId) || null;
  }

  /**
   * List scan results
   */
  listScanResults(filters: {
    configurationId?: string;
    status?: ScanResult['status'];
    startDate?: Date;
    endDate?: Date;
    limit?: number;
    offset?: number;
  }): ScanResult[] {
    let results = Array.from(this.scanResults.values());

    // Apply filters
    if (filters.configurationId) {
      results = results.filter(r => r.configurationId === filters.configurationId);
    }
    if (filters.status) {
      results = results.filter(r => r.status === filters.status);
    }
    if (filters.startDate) {
      results = results.filter(r => r.startedAt >= filters.startDate!);
    }
    if (filters.endDate) {
      results = results.filter(r => r.startedAt <= filters.endDate!);
    }

    // Sort by start date desc
    results.sort((a, b) => b.startedAt.getTime() - a.startedAt.getTime());

    // Apply pagination
    const start = filters.offset || 0;
    const end = filters.limit ? start + filters.limit : results.length;
    
    return results.slice(start, end);
  }

  /**
   * Generate security report
   */
  async generateSecurityReport(
    type: SecurityReport['type'],
    period: { start: Date; end: Date },
    options: {
      includeDetails?: boolean;
      includeTrends?: boolean;
      format?: 'json' | 'pdf' | 'html';
    } = {}
  ): Promise<SecurityReport> {
    const vulnerabilities = this.listVulnerabilities({
      startDate: period.start,
      endDate: period.end
    });

    const report: SecurityReport = {
      id: this.generateReportId(),
      title: `Security Report - ${type}`,
      description: `Security report for period ${period.start.toISOString()} to ${period.end.toISOString()}`,
      type,
      generatedAt: new Date(),
      period,
      summary: {
        totalVulnerabilities: vulnerabilities.length,
        newVulnerabilities: vulnerabilities.filter(v => v.discoveredAt >= period.start).length,
        fixedVulnerabilities: vulnerabilities.filter(v => v.status === 'fixed').length,
        riskScore: this.calculateRiskScore(vulnerabilities),
        complianceScore: 85, // Would integrate with compliance service
        trendDirection: 'improving' // Would calculate from historical data
      },
      findings: vulnerabilities,
      recommendations: this.generateRecommendations(vulnerabilities),
      attachments: [],
      metadata: {
        options,
        generatedBy: 'vulnerability-scanner'
      }
    };

    this.reports.set(report.id, report);

    logger.info('Security report generated', {
      reportId: report.id,
      type,
      vulnerabilities: report.summary.totalVulnerabilities,
      riskScore: report.summary.riskScore
    });

    this.emit('reportGenerated', report);
    return report;
  }

  private setupDefaultConfigurations(): void {
    // Default comprehensive scan configuration
    const defaultConfig: ScanConfiguration = {
      id: 'default-comprehensive',
      name: 'Comprehensive Security Scan',
      description: 'Full security scan including SAST, DAST, and dependency checks',
      type: 'full',
      enabled: true,
      schedule: '0 2 * * 0', // Weekly on Sunday at 2 AM
      targets: [],
      scanners: [
        {
          type: 'sast',
          enabled: true,
          configuration: { includeExperimental: false },
          timeout: 1800, // 30 minutes
          retryCount: 2
        },
        {
          type: 'dast',
          enabled: true,
          configuration: { maxDepth: 3 },
          timeout: 3600, // 1 hour
          retryCount: 1
        },
        {
          type: 'dependency',
          enabled: true,
          configuration: { includeDevDependencies: true },
          timeout: 300, // 5 minutes
          retryCount: 2
        },
        {
          type: 'secrets',
          enabled: true,
          configuration: { includeGitHistory: false },
          timeout: 600, // 10 minutes
          retryCount: 1
        }
      ],
      notifications: [
        {
          enabled: true,
          channels: ['email'],
          severity: ['critical', 'high'],
          recipients: ['security@company.com']
        }
      ],
      reportingOptions: {
        generateReport: true,
        formats: ['json', 'pdf'],
        includeDetails: true,
        includeFalsePositives: false
      },
      createdAt: new Date(),
      updatedAt: new Date()
    };

    this.scanConfigurations.set(defaultConfig.id, defaultConfig);

    logger.info('Default scan configurations loaded', {
      configurationCount: this.scanConfigurations.size
    });
  }

  private startScanProcessor(): void {
    // Process scan queue every 10 seconds
    setInterval(() => {
      this.processScanQueue();
    }, 10000);
  }

  private async processScanQueue(): Promise<void> {
    if (this.activeScanners.size >= this.maxConcurrentScans) {
      return;
    }

    const scanId = this.scanQueue.shift();
    if (!scanId) {
      return;
    }

    this.activeScanners.add(scanId);

    try {
      await this.executeScan(scanId);
    } catch (error) {
      logger.error('Scan execution failed', {
        scanId,
        error: error.message
      });
    } finally {
      this.activeScanners.delete(scanId);
    }
  }

  private scheduleScans(): void {
    // Schedule scans based on configuration
    for (const config of this.scanConfigurations.values()) {
      if (config.enabled && config.schedule) {
        // Simplified scheduling - would use proper cron in production
        const interval = setInterval(async () => {
          try {
            await this.startScan(config.id, 'scheduled');
          } catch (error) {
            logger.error('Scheduled scan failed', {
              configurationId: config.id,
              error: error.message
            });
          }
        }, 24 * 60 * 60 * 1000); // Daily
        
        this.scanSchedules.set(config.id, interval);
      }
    }
  }

  private async sendNotifications(config: ScanConfiguration, result: ScanResult): Promise<void> {
    for (const notification of config.notifications) {
      if (!notification.enabled) continue;

      const relevantVulns = result.vulnerabilities.filter(v => 
        notification.severity.includes(v.severity)
      );

      if (relevantVulns.length === 0) continue;

      logger.info('Sending scan notification', {
        scanId: result.id,
        channels: notification.channels,
        vulnerabilities: relevantVulns.length
      });

      // Mock notification sending
      for (const channel of notification.channels) {
        await this.sendNotificationToChannel(channel, notification, result, relevantVulns);
      }
    }
  }

  private async sendNotificationToChannel(
    channel: string,
    notification: NotificationConfig,
    result: ScanResult,
    vulnerabilities: Vulnerability[]
  ): Promise<void> {
    switch (channel) {
      case 'email':
        logger.info('Sending email notification', {
          recipients: notification.recipients,
          vulnerabilities: vulnerabilities.length
        });
        break;
      case 'slack':
        logger.info('Sending Slack notification', {
          vulnerabilities: vulnerabilities.length
        });
        break;
      case 'webhook':
        logger.info('Sending webhook notification', {
          url: notification.webhookUrl,
          vulnerabilities: vulnerabilities.length
        });
        break;
    }
  }

  private async generateScanReport(result: ScanResult): Promise<void> {
    const config = this.scanConfigurations.get(result.configurationId);
    if (!config) return;

    logger.info('Generating scan report', {
      scanId: result.id,
      formats: config.reportingOptions.formats
    });

    // Mock report generation
    for (const format of config.reportingOptions.formats) {
      await this.generateReportInFormat(result, format);
    }
  }

  private async generateReportInFormat(result: ScanResult, format: string): Promise<void> {
    logger.info('Generating report in format', {
      scanId: result.id,
      format
    });
    // Mock report generation
  }

  private calculateRiskScore(vulnerabilities: Vulnerability[]): number {
    if (vulnerabilities.length === 0) return 0;

    const weights = { critical: 10, high: 7, medium: 4, low: 2, info: 1 };
    const totalWeight = vulnerabilities.reduce((sum, v) => sum + weights[v.severity], 0);
    const maxWeight = vulnerabilities.length * 10;
    
    return Math.round((totalWeight / maxWeight) * 100);
  }

  private generateRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations: string[] = [];

    const critical = vulnerabilities.filter(v => v.severity === 'critical').length;
    const high = vulnerabilities.filter(v => v.severity === 'high').length;

    if (critical > 0) {
      recommendations.push(`Address ${critical} critical vulnerabilities immediately`);
    }
    if (high > 0) {
      recommendations.push(`Prioritize ${high} high severity vulnerabilities`);
    }

    const categories = new Set(vulnerabilities.map(v => v.category));
    if (categories.has('injection')) {
      recommendations.push('Implement input validation and parameterized queries');
    }
    if (categories.has('xss')) {
      recommendations.push('Implement proper output encoding and CSP headers');
    }
    if (categories.has('dependency')) {
      recommendations.push('Update dependencies to latest secure versions');
    }

    return recommendations;
  }

  private updateScanResult(result: ScanResult): void {
    this.scanResults.set(result.id, result);
    this.emit('scanProgress', result);
  }

  private generateScanId(): string {
    return `SCAN-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateVulnId(): string {
    return `VULN-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateReportId(): string {
    return `SRPT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * Shutdown service
   */
  async shutdown(): Promise<void> {
    // Clear scan schedules
    for (const interval of this.scanSchedules.values()) {
      clearInterval(interval);
    }
    this.scanSchedules.clear();

    // Clear active scanners
    this.activeScanners.clear();
    this.scanQueue.length = 0;

    logger.info('Vulnerability scanner shut down');
  }
}

export const vulnerabilityScanner = new VulnerabilityScanner();